initialize() {

	// ******************************
	// Simulation parameters
	// ******************************
	
	defineConstant("chr_size", 99999); // the total length of the chromosome
	defineConstant("pop_size", 200); // initial population size
	defineConstant("m", 0.01);   // the bidirectional migration rate
	defineConstant("delta", 0.05); // the per-generation change in selective optimum
	defineConstant("phenotypic_optimum", 10.0); // the (initial) phenotypic optimum
	
	
	// ******************************
	// Reproductive isolation parameters
	// ******************************
	 
	defineConstant("ri_n", 10); // The number of ri_loci
	defineConstant("ri_arch","clustered"); //Whether the ri_loci are clumped or spread out.
	
	if (ri_arch == "diffuse"){
	
		defineConstant("ri_loci", c(1:ri_n)*integerDiv(chr_size, ri_n)); 
		
	} else if (ri_arch == "clustered"){
	
		defineConstant("chr_size_third", integerDiv(chr_size, 3)); 
		defineConstant("ri_loci", c(1:ri_n)*integerDiv(chr_size_third, ri_n) + chr_size_third); 
		
	}
	
	defineConstant("ri", 0.1); // the selection coefficient for RI alleles (all identical)
	
	// ******************************
	// Mutation types
	// ******************************
	
	scriptForQTLs = "if (runif(1) < 0.5) -0.1; else 0.1;"; // binary QTL alleles?
	
	initializeMutationType("m1", 0.5, "n", 0.0, 0.0);  // Reproductive isolation (deleterious in p2)
	initializeMutationType("m2", 0.5, "n", 0.0, 0.0);  // Reproductive isolation (deleterious in p1)
	initializeMutationType("m3", 0.5, "s", scriptForQTLs);  // Environmentally-sensitive QTL 
	initializeMutationType("m4", 0.5, "f", 0.0);  // a neutral allele
	
	m3.convertToSubstitution = F;
	m3.mutationStackPolicy = "l";

	
	// colors, for use in SLiMGui
	m1.color = "blue";
	m2.color = "green";
	m3.color = "red";
	m4.color = "grey40";
	
		// ******************************
	// Genome properties
	// ******************************
	
	// TBD prevent back mutations of RI alleles

	initializeGenomicElementType("g1", c(m3,m4),  c(0.5,0.5)); // only QTL and neutral alleles mutate in
	initializeGenomicElementType("g2", c(m4,m1,m2),  c(1e-200,0.0,0.0)); // RI loci are static
	
	//define the non-RI regions		
	for (index in 0:(size(ri_loci)-1))
		if (index == 0){
			initializeGenomicElement(g1, 0, ri_loci[index]-1);
			initializeGenomicElement(g1, ri_loci[index]+1, ri_loci[index+1]-1);
			}
		else if (index == size(ri_loci)-1)
			initializeGenomicElement(g1, ri_loci[index]+1, chr_size);
		else
			initializeGenomicElement(g1, ri_loci[index]+1, ri_loci[index+1]-1);
	
	// define the RI regions (again, to prevent back-mutations at the RI loci)
	for (index in 0:(size(ri_loci)-1))
			initializeGenomicElement(g2, ri_loci[index], ri_loci[index]);

	initializeMutationRate(1.5e-8);
	initializeRecombinationRate(1e-8);
}

1 early() {

	sim.addSubpop("p1", 500);
	sim.addSubpop("p2", 500);

	// initialize RI loci
	for (i in ri_loci){
	 
		p1.individuals.genomes.addNewDrawnMutation(m1, i); 
		p2.individuals.genomes.addNewDrawnMutation(m2, i);
		
	}
	
	p1.setMigrationRates(p2, m);   
	p2.setMigrationRates(p1, m); 
	
	//sim.registerEarlyEvent("s2", s1.source, 2, 2);
}

1: late() {

// ************************************************************
	// p1: QTL-based fitness for the environmentally-sensitive alleles
	// ************************************************************
	
	p1_inds = p1.individuals;
	phenotypes = asInteger(p1_inds.sumOfMutationsOfType(m3));
	ri_phenotypes = (p1_inds.countOfMutationsOfType(m2)/ri_n);
	//ri_phenotypes = ri * (p1_inds.countOfMutationsOfType(m1) - p1_inds.countOfMutationsOfType(m2))/; 
	
	//cat(ri_phenotypes);
	

	p1_inds.tag = phenotypes; 
	p1_inds.x = ri_phenotypes; // the average RI discount (load) for the population
	
	// ************************************************************
	// p2: QTL-based fitness for the environmentally-sensitive alleles
	// ************************************************************
	
	p2_inds = p2.individuals;
	phenotypes = asInteger(p2_inds.sumOfMutationsOfType(m3));
	ri_phenotypes = (p2_inds.countOfMutationsOfType(m1)/ri_n); // max ri pheno = 1
	//ri_phenotypes = (ri * (p2_inds.countOfMutationsOfType(m2) - p2_inds.countOfMutationsOfType(m1))); 
	 

	p2_inds.tag = phenotypes; 
	p2_inds.x = ri_phenotypes; // the average RI discount (load) for the population

	// construct phenotypes for the additive effects of QTLs
	//inds = sim.subpopulations.individuals;
	//inds.tag = asInteger(inds.sumOfMutationsOfType(m3));
	
}

fitness(m2) {
	// the QTLs themselves are neutral; their effect is handled below
	return 1.0;
}
fitness(NULL, p1) {

	// ri discounts fitness via a percentage
	
	return (1-individual.x) * dnorm(phenotypic_optimum - individual.tag, 0.0, 5.0);
}
fitness(NULL, p2) {

	// ri discounts fitness via a percentage
	
	return (1-individual.x) * dnorm(phenotypic_optimum - individual.tag, 0.0, 5.0);
}

1:5000 early() {

	if (sim.generation % 100 == 0){
	
	cat("-------------------------------\n");
	cat("Output for end of generation " + (sim.generation - 1) + ":\n\n");
	
	// Output population fitness values
	cat("p1 mean fitness = " + mean(p1.cachedFitness(NULL)) + "\n");
	cat("p2 mean fitness = " + mean(p2.cachedFitness(NULL)) + "\n");
	
	// Output population additive QTL-based phenotypes
	cat("p1 mean phenotype = " + mean(p1.individuals.tag) + "\n");
	cat("p2 mean phenotype = " + mean(p2.individuals.tag) + "\n");
	}
	
}
