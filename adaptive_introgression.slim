initialize() {
	initializeSLiMModelType("nonWF");
	
	
	defineConstant("initial_pop_size", 250); // initial population size
	defineConstant("K", 250); // carrying capacity (per subpopulation)
	defineConstant("pheno_opt2", 10.0); // the final optimum (starts at 0, moves to opt2)
	defineConstant("m", 0.01);   // the bidirectional migration rate
	
	initializeMutationType("m1", 0.5, "e", 0.0);  // Reproductive isolation (deleterious in p2)
	initializeMutationType("m2", 0.5, "e", 0.0);  // Reproductive isolation (deleterious in p1)
	initializeMutationType("m3", 0.5, "n", 0.0, 1.0);  // Environmentally sensitive QTL (adaptative everywhere)

	initializeGenomicElementType("g1", c(m1,m2,m3),  c(0.01,0.01,0.98));
	
	initializeGenomicElement(g1, 0, 99999);
	initializeMutationRate(1e-7);
	initializeRecombinationRate(1e-8);
}
reproduction() {
	subpop.addCrossed(individual, subpop.sampleIndividuals(1));
	return NULL;
}
1 early() {
	sim.addSubpop("p1", initial_pop_size);
	sim.addSubpop("p2", initial_pop_size);

}
early() {
	
	// QTL-based fitness for the environmentally-sensitive alleles
	inds = sim.subpopulations.individuals;
	phenotypes = inds.sumOfMutationsOfType(m3);
	optimum = (sim.generation/5000) * pheno_opt2; // optimum gradually moves to opt2
	deviations = optimum - phenotypes;
	fitnessFunctionMax = dnorm(0.0, 0.0, 5.0);
	adaptation = dnorm(deviations, 0.0, 5.0) / fitnessFunctionMax;
	inds.fitnessScaling = 0.1 + adaptation *  0.9 ;	
	inds.x = asFloat(phenotypes);   // just for output below

	
	// density-dependence with a maximum benefit at low density
	p1.fitnessScaling = min(K / p1.individualCount, 1.5);
	p2.fitnessScaling = min(K / p2.individualCount, 1.5);
	
	// migration
	nIndividuals = sum(sim.subpopulations.individualCount);
	nMigrants = rpois(1, nIndividuals * m);
	migrants = sample(sim.subpopulations.individuals, nMigrants);
	
	for (migrant in migrants)
	{
		do dest = sample(sim.subpopulations, 1);
		while (dest == migrant.subpopulation);
		
		dest.takeMigrants(migrant);
	}
}

// divergent selection 
fitness(m3) { return 1.0; }
fitness(m1, p2) { return -0.1; }
fitness(m2, p1) { return -0.1; }


5000 late() { sim.simulationFinished(); }
