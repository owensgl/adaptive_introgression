initialize() {

	initializeSLiMModelType("nonWF"); 
	
	// ******************************
	// Simulation parameters
	// ******************************
	
	defineConstant("initial_pop_size", 250); // initial population size
	defineConstant("K", 250); // carrying capacity (per subpopulation)
	defineConstant("pheno_opt2", 100.0); // the final optimum (starts at 0, moves to opt2)
	defineConstant("m", 0.01);   // the bidirectional migration rate
	defineConstant("ri", -0.01); // the selection coefficient for RI alleles
	defineConstant("ri_loci", (1:10*10000)-1); // the positions of the RI loci in both populations
	
	// ******************************
	// Mutation types
	// ******************************
	
	initializeMutationType("m1", 0.5, "e", 0.0);  // Reproductive isolation (deleterious in p2)
	initializeMutationType("m2", 0.5, "e", 0.0);  // Reproductive isolation (deleterious in p1)
	
	m1.convertToSubstitution = F; // the RI alleles should never fix (in the meta population) but just in case
	m2.convertToSubstitution = F; 
	
	initializeMutationType("m3", 0.5, "n", 0.0, 1.0);  // Environmentally sensitive QTL (adaptative everywhere)
	
	// ******************************
	// Genome properties
	// ******************************

	initializeGenomicElementType("g1", c(m1,m2,m3),  c(0.00,0.00,1.0)); // only QTL alleles arise from mutations
	
	initializeGenomicElement(g1, 0, 99999);
	initializeMutationRate(1e-7);
	initializeRecombinationRate(1e-8);
}
reproduction() {
	subpop.addCrossed(individual, subpop.sampleIndividuals(1));
	return NULL;
}
1 early() {
	
	// ******************************
	// Initialize populations
	// ******************************
	
	sim.addSubpop("p1", initial_pop_size);
	sim.addSubpop("p2", initial_pop_size);
	
	// ******************************
	// Initialize RI
	// ******************************
	
	// the positions of the RI alleles (same in both pops, for now)
	// ri_loci = (1:10*10000)-1;
	
	// individuals who will recieve the RI alleles (everyone, in this case)
	p1_inds = sample(p1.individuals, p1.individualCount); // p1 inds, polymorphic
	p2_inds = sample(p2.individuals, p2.individualCount); // p2 inds, polymorphic
	
	// place each adaptive allele in both populations
	for (i in ri_loci){
	 
		p1.individuals.genomes.addNewDrawnMutation(m1, i); 
		p2.individuals.genomes.addNewDrawnMutation(m2, i);
		
	}


}
early() {

	
	// ************************************************************
	// QTL-based fitness for the environmentally-sensitive alleles
	// ************************************************************
	
	inds = sim.subpopulations.individuals;
	phenotypes = inds.sumOfMutationsOfType(m3);
	optimum = (sim.generation/5000) * pheno_opt2; // optimum gradually moves to opt2
	deviations = optimum - phenotypes;
	fitnessFunctionMax = dnorm(0.0, 0.0, 5.0);
	adaptation = dnorm(deviations, 0.0, 5.0) / fitnessFunctionMax;
	inds.fitnessScaling = 0.1 + adaptation *  0.9 ;	
	inds.x = asFloat(phenotypes);   // just for output below

	// ******************************
	// Density-dependence
	// ******************************
	
	p1.fitnessScaling = min(K / p1.individualCount, 1.5);
	p2.fitnessScaling = min(K / p2.individualCount, 1.5);
	
	// ******************************
	// Migration
	// ******************************
	
	nIndividuals = sum(sim.subpopulations.individualCount);
	nMigrants = rpois(1, nIndividuals * m);
	migrants = sample(sim.subpopulations.individuals, nMigrants);
	
	for (migrant in migrants)
	{
		do dest = sample(sim.subpopulations, 1);
		while (dest == migrant.subpopulation);
		
		dest.takeMigrants(migrant);
	}
}

// ******************************
// Fitness callbacks
// ******************************

fitness(m3) { return 1.0; }
fitness(m1, p2) { return ri; }
fitness(m2, p1) { return ri; }

late() {

	// ******************************
	// Print information about run.
	// ******************************
	
	if ((p1.individualCount == 0) | (p2.individualCount == 0))
	{
		// stop at extinction
		if (p1.individualCount == 0) 
		{
			catn("Pop 1 extinction in generation " + sim.generation + ".");
		}else
		{
			catn("Pop 2 extinction in generation " + sim.generation + ".");
		}
		sim.simulationFinished();
	}
	else
	{
		if (sim.generation % 100 == 0)
		{
			// output the phenotypic mean and pop size
		
			cat(sim.generation + ": " + p1.individualCount + ":" + p2.individualCount + " individuals");
			catn();
		}
	}
}

5000 late() { sim.simulationFinished(); }
