initialize() {

	// ******************************
	// Simulation parameters
	// ******************************
	
	defineConstant("chr_size", 99999); // the total length of the chromosome
	defineConstant("pop_size", 400); // initial population size for p1 and p2
	defineConstant("m", 0.01);   // the bidirectional migration rate
	defineConstant("delta", 0.001); // the per-generation change in selective optimum
	defineConstant("initial_optimum", 0.0); // the (initial) phenotypic optimum
	initializeMutationRate(1.5e-7);
	initializeRecombinationRate(1e-7);
	
	// ******************************
	// Burn-in parameters
	// ******************************
	
	defineConstant("burn_in_generations", 4000); // the number of burn-in generations (not yet implemented)
	defineConstant("burn_in_fluct_period", 1000); // no. generations between changes in optimum
	defineConstant("burn_in_optimum", 5.0); // the amplitude of the burn-in flucation (opt1 = +, opt2 = -)
	

	// ******************************
	// BDM location parameters
	// ******************************
	
	defineConstant("bdm_s", -0.5); //The multiplied penalty for not having 4 copies of a BDM allele;
	
	defineConstant("bdm_n",  10); // The number of bdm_loci (minimum 2)
	defineConstant("bdm_arch","clustered"); //Whether the bdm_loci are clumped or spread out.
	
	if (bdm_arch == "diffuse"){
	
		defineConstant("bdm_loci", c(1:bdm_n) * integerDiv(chr_size, (bdm_n+1))); 
		
	} else if (bdm_arch == "clustered"){
		
		defineConstant("cluster_proportion", 6); // the size of the cluster, 1 = whole chromosome, 2 = half, 3 = third, etc.
		defineConstant("cluster_size", integerDiv(chr_size, cluster_proportion)); // the size of the BDM cluster, in bp
		defineConstant("cluster_start", integerDiv(chr_size, 2) - integerDiv(chr_size, cluster_proportion*2)); // the starting locus of the cluster
		
		defineConstant("bdm_loci", c(1:bdm_n) * integerDiv(cluster_size, (bdm_n+1)) + cluster_start); // define the bdm loci

	}
	
	// ******************************
	// BDM epistasis parameters
	// ******************************
	
	
	// create 
	bdm_loci_p1 = 0:(bdm_n-1); 
	bdm_loci_p2 = rep(1e10, bdm_n);

	for (i in 0:(size(bdm_loci_p1)-1)){
			
			// define invalid loci (previously selected loci; also the current locus)
			invalid_loci = unique(c(bdm_loci_p2, bdm_loci_p1[i]));
			
			//where are the invalid loci within the loci_p1 vector?
			matches = match(invalid_loci, bdm_loci_p1)[ match(invalid_loci, bdm_loci_p1) >= 0];
			
			valid_loci = bdm_loci_p1;
			
			// if we were using r, we could use %in%, but instead
			// assign a dummy value to loci that are invalid
			// (or in the case of a single value, just assign it as the valid locus)
			if(size(matches) > 1){
			
					valid_loci[matches] = 1e10;
	  		   
	  		   //for (j in 0:(size(matches)-1)){
				//	valid_loci[matches[j]] = 1e10;
				
	  		   //}
	  		
	  		} else{
	  		
	  			valid_loci = bdm_loci_p1[bdm_loci_p1 != matches[0]];
	  		
	  		}
	  		// purge the vector of the dummy values
	  		valid_loci = valid_loci[valid_loci < 1e10];
	  		valid_loci = unique(valid_loci);
	  
	  // if there is only one valid locus, assign it to the p2_bdm vector
	  // otherwise, draw a random sample from the available loci
	  if(size(valid_loci) <= 1){
	  
	    bdm_loci_p2[i] = valid_loci;
	    
	  } else{
	  
	    bdm_loci_p2[i] = sample(valid_loci, 1);
	    
	  }
	  
	  cat("loci_p2: " + paste(bdm_loci_p2)+ "\n");
	  
	}

	// ******************************
	// Mutation types
	// ******************************
	
	scriptForQTLs = "if (runif(1) < 0.5) -0.5; else 0.5;"; // binary QTL alleles?
	
	initializeMutationType("m3", 0.5, "s", scriptForQTLs);  // Environmentally-sensitive QTL 
	initializeMutationType("m4", 0.5, "f", 0.0);  // a neutral allele
	initializeMutationType("m5", 0.5, "f", bdm_s);  // The BDM loci p1 half
	initializeMutationType("m6", 0.5, "f", bdm_s);  // The BDM loci p2 half

	m3.convertToSubstitution = F;
	m3.mutationStackPolicy = "l";
	m5.convertToSubstitution = F;
	m6.convertToSubstitution = F;


	
	// colors, for use in SLiMGui
	//m1.color = "blue";
	//m2.color = "green";
	m3.color = "red";
	m4.color = "grey40";
	m5.color = "yellow";
	m6.color = "orange";

	
   // ******************************
	// Genome properties
	// ******************************

	initializeGenomicElementType("g1", c(m3,m4),  c(0.5,0.5)); // only QTL and neutral alleles mutate in
	initializeGenomicElementType("g2", c(m4,m5,m6),  c(1e-200,0.0,0.0)); // RI loci are static
	
	//define the non-RI regions		
	for (index in 0:(size(bdm_loci)-1))
		if (index == 0){
			initializeGenomicElement(g1, 0, bdm_loci[index]-1);
			initializeGenomicElement(g1, bdm_loci[index]+1, bdm_loci[index+1]-1);
			}
		else if (index == size(bdm_loci)-1)
			initializeGenomicElement(g1, bdm_loci[index]+1, chr_size);
		else
			initializeGenomicElement(g1, bdm_loci[index]+1, bdm_loci[index+1]-1);
	
	// define the RI regions (again, to prevent back-mutations at the RI loci)
	for (index in 0:(size(bdm_loci)-1))
			initializeGenomicElement(g2, bdm_loci[index], bdm_loci[index]);

}

1 early() {

	sim.addSubpop("p1", pop_size);
	sim.addSubpop("p2", pop_size);

	p1.setMigrationRates(p2, m);   
	p2.setMigrationRates(p1, m); 
	
	
	// add in BDM loci
	for (i in bdm_loci){
	 
	p2.individuals.genomes.addNewDrawnMutation(m5, i);
	p1.individuals.genomes.addNewDrawnMutation(m6, i);
		
	}
}

1: late() {

	// ************************************************************
	// p1: QTL-based fitness for the environmentally-sensitive alleles
	// ************************************************************
	
	p1_inds = p1.individuals;
	phenotypes = asInteger(p1_inds.sumOfMutationsOfType(m3));
	//ri_phenotypes = (p1_inds.countOfMutationsOfType(m2)/ri_n);
	//ri_phenotypes = ri * (p1_inds.countOfMutationsOfType(m1) - p1_inds.countOfMutationsOfType(m2))/; 
	
	//cat(ri_phenotypes);
	
	p1_inds.tag = phenotypes; 
	//p1_inds.x = ri_phenotypes; // the average RI discount (load) for the population
	
	// ************************************************************
	// p2: QTL-based fitness for the environmentally-sensitive alleles
	// ************************************************************
	
	p2_inds = p2.individuals;
	phenotypes = asInteger(p2_inds.sumOfMutationsOfType(m3));
	//ri_phenotypes = (p2_inds.countOfMutationsOfType(m1)/ri_n); // max ri pheno = 1
	//ri_phenotypes = (ri * (p2_inds.countOfMutationsOfType(m2) - p2_inds.countOfMutationsOfType(m1))); 

	p2_inds.tag = phenotypes; 
	//p2_inds.x = ri_phenotypes; // the average RI discount (load) for the population

	// construct phenotypes for the additive effects of QTLs
	//inds = sim.subpopulations.individuals;
	//inds.tag = asInteger(inds.sumOfMutationsOfType(m3));
	
}

fitness(m3) {
	// the QTLs themselves are neutral; their effect is handled below
	return 1.0;
}

fitness(m5) {
	if ((genome1.countOfMutationsOfType(m5) == 2) & (genome2.countOfMutationsOfType(m5) == 2))
		return 1.0;
	else
		return relFitness;
}

fitness(m6) {
	if ((genome1.countOfMutationsOfType(m6) == 2) & (genome2.countOfMutationsOfType(m6) == 2))
		return 1.0;
	else
		return relFitness;
}

fitness(NULL, p1) {
	
	// if in the burn in period, compute optimum based on burn in fluctations
	
	if (sim.generation <= burn_in_generations){
		
		// cosine with 1/2 period = burn_in_fluct_period, amplitude = burn_in_optimum
		current_optimum = cos(sim.generation/(3.14159 * (burn_in_fluct_period/10))) * burn_in_optimum;
	
	} else{
	
		current_optimum = initial_optimum + delta * sim.generation;
	}
	
	// ri discounts fitness by a percentage, scaled by max_ri

	return dnorm(current_optimum - individual.tag, 0.0, 5.0);
	
}

fitness(NULL, p2) {
	
	// if in the burn in period, compute optimum based on burn in fluctations
	
	if (sim.generation <= burn_in_generations){
		
		// cosine with 1/2 period = burn_in_fluct_period, amplitude = burn_in_optimum
		current_optimum = cos(sim.generation/(3.14159 * (burn_in_fluct_period/10))) * burn_in_optimum;
	
	} else{
	
		current_optimum = initial_optimum + delta * sim.generation;
	}
	
	// ri discounts fitness by a percentage, scaled by max_ri

	return dnorm(current_optimum - individual.tag, 0.0, 5.0);
	
}


1:10000 early() {

	if (sim.generation % 100 == 0){
	
	if (sim.generation <= burn_in_generations){
		cat("BURN IN" + "\n");
	}
	
	if (sim.generation <= burn_in_generations){
		
		// cosine with 1/2 period = burn_in_fluct_period, amplitude = burn_in_optimum
		current_optimum = cos(sim.generation/(3.14159 * (burn_in_fluct_period/10))) * burn_in_optimum;
	
	} else{
	
		current_optimum = initial_optimum + delta * sim.generation;
	}
	
	cat("Output for end of generation " + (sim.generation) + ":\n");
	cat("-------------------------------\n");
	
	// Output population fitness values
	cat("p1 mean fitness = " + mean(p1.cachedFitness(NULL)) + "\n");
	cat("p2 mean fitness = " + mean(p2.cachedFitness(NULL)) + "\n");
	
	// print the current optimum
	cat("current phenotypic optimum = " + current_optimum + "\n"); 
	
	// Output population additive QTL-based phenotypes
	cat("p1 mean phenotype = " + mean(p1.individuals.tag) + "\n");
	cat("p2 mean phenotype = " + mean(p2.individuals.tag) + "\n\n");
	}
	
}
